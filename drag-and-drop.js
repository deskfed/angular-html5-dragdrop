// Generated by CoffeeScript 1.6.2
/*
Created with IntelliJ IDEA.
User: Ganaraj.Pr
Date: 11/10/13
Time: 11:27
To change this template use File | Settings | File Templates.
*/


(function() {
  angular.module("ddDragDrop", []).factory('ddChannel', function() {
    var activateChannelListeners, currChannel, currDraggable, deactivateChannelListeners;

    currChannel = null;
    currDraggable = null;
    activateChannelListeners = {};
    deactivateChannelListeners = {};
    return {
      getDragElement: function() {
        return currDraggable;
      },
      setDragElement: function(element) {
        if (element == null) {
          element = null;
        }
        return currDraggable = element;
      },
      onChannelActivate: function(channel, listener) {
        if (!activateChannelListeners[channel]) {
          activateChannelListeners[channel] = [];
        }
        return activateChannelListeners[channel].push(listener);
      },
      onChannelDeactivate: function(channel, listener) {
        if (!deactivateChannelListeners[channel]) {
          deactivateChannelListeners[channel] = [];
        }
        return deactivateChannelListeners[channel].push(listener);
      },
      activateChannel: function(channel, element) {
        var fn, _i, _len, _ref, _results;

        this.setDragElement(element);
        _ref = activateChannelListeners[channel];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn());
        }
        return _results;
      },
      deactivateChannel: function(channel) {
        var fn, _i, _len, _ref, _results;

        this.setDragElement();
        _ref = deactivateChannelListeners[channel];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn());
        }
        return _results;
      },
      removeChannelListener: function(channel, listener) {
        var _ref;

        return (_ref = channelListeners[channel]) != null ? _ref.splice(channelListeners.indexOf(listener, 1)) : void 0;
      }
    };
  }).directive('ddDraggable', function($parse, $rootScope, $document, $timeout, ddChannel) {
    if (window.jQuery && window.jQuery.event.props.indexOf('dataTransfer' === -1)) {
      window.jQuery.event.props.push("dataTransfer");
    }
    return function(scope, element, attrs) {
      var dragData;

      dragData = null;
      attrs.ddChannel = attrs.ddChannel || 'ddDefaultChannel';
      element.attr("draggable", true);
      scope.$watch(attrs.ddDragData, function(newValue) {
        return dragData = newValue;
      });
      element.bind('dragstart', function(e) {
        var coords, el;

        console.log('dragStart');
        angular.element(this).data('ddDragData', dragData);
        ddChannel.activateChannel(attrs.ddChannel, this);
        if (attrs.ddDragHelper) {
          el = angular.element($parse(attrs.ddDragHelper)(scope));
          coords = $parse(attrs.ddDragHelperCoords)(scope) || {
            x: 0,
            y: 0
          };
          $document.find("body").append(el);
          e.dataTransfer.setDragImage(el[0], coords.x, coords.y);
          $timeout((function() {
            el.remove();
          }), 0);
        }
      });
      return element.bind("dragend", function(e) {
        var fn;

        console.log('dragend');
        ddChannel.deactivateChannel(attrs.ddChannel);
        if (e.dataTransfer && e.dataTransfer.dropEffect !== "none") {
          if (attrs.ddOnDropSuccess) {
            fn = $parse(attrs.ddOnDropSuccess);
            scope.$apply(function() {
              fn(scope, {
                $event: e
              });
            });
          }
        }
      });
    };
  }).directive('ddDroppable', function($parse, $rootScope, $document, $timeout, $log, ddChannel) {
    var contains, getBox, getCoords, isBetween, isWithin;

    getCoords = function(evt) {
      var _ref, _ref1;

      return {
        x: ((_ref = evt.originalEvent) != null ? _ref.clientX : void 0) || evt.clientX,
        y: ((_ref1 = evt.originalEvent) != null ? _ref1.clientY : void 0) || evt.clientY
      };
    };
    getBox = function(element) {
      var offset;

      offset = element.offset();
      return {
        top: offset.top,
        left: offset.left,
        bottom: offset.top + element.outerHeight(),
        right: offset.left + element.outerWidth()
      };
    };
    contains = function(box, coords) {
      return coords.x < box.right && coords.x > box.left && coords.y < box.bottom && coords.y > box.top;
    };
    isWithin = function(element, evt) {
      return contains(getBox(element), getCoords(evt));
    };
    isBetween = function(direction, collection, over, evt) {
      var coords, firstElement, lastElement, targetBox;

      targetBox = getBox(over);
      coords = getCoords(evt);
      targetBox.middleX = (targetBox.right - targetBox.left) / 2 + targetBox.left;
      targetBox.middleY = (targetBox.bottom - targetBox.top) / 2 + targetBox.top;
      firstElement = lastElement = null;
      if (!contains(targetBox, coords)) {
        return;
      }
      if (direction === 'horizontal') {
        if (coords.x > targetBox.middleX) {
          lastElement = over;
          firstElement = over.next();
        } else {
          firstElement = over;
          lastElement = over.prev();
        }
      }
      return {
        first: firstElement,
        last: lastElement
      };
    };
    return function(scope, element, attrs) {
      var actionClasses, addMarkers, betweenItems, dropModel, onDragEnter, onDragLeave, onDragOver, onDrop, removeMarkers, sortDir, sortWithin;

      sortWithin = null;
      dropModel = null;
      scope.$watch(attrs.ddDroppable, function(newModel) {
        return dropModel = newModel;
      });
      sortDir = attrs.ddSort;
      betweenItems = null;
      if (!(sortDir && /vertical|horizontal/.test(sortDir))) {
        throw 'dd-sort attribute must be either "vertical" or "horizontal"';
      }
      if (!angular.isArray(dropModel)) {
        $log('ddDroppable attribute needs to point to an available array');
      }
      attrs.ddChannel = attrs.ddChannel || 'ddDefaultChannel';
      actionClasses = {
        ddDropTargetClass: attrs.ddDropTargetClass || 'drop-target',
        ddDragEnterClass: attrs.ddDragEnterClass || 'drag-enter',
        ddDragSortClass: attrs.ddDragSortClass || 'drag-sort'
      };
      removeMarkers = function(elements) {
        if (!elements) {
          return;
        }
        elements.first.removeClass(actionClasses.ddDragSortClass + '-before');
        return elements.last.removeClass(actionClasses.ddDragSortClass + '-after');
      };
      addMarkers = function(elements) {
        if (!elements) {
          return;
        }
        elements.first.addClass(actionClasses.ddDragSortClass + '-before');
        return elements.last.addClass(actionClasses.ddDragSortClass + '-after');
      };
      onDragOver = function(e) {
        var oldBetween;

        if (e.preventDefault) {
          e.preventDefault();
        }
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        e.dataTransfer.dropEffect = "move";
        if (sortDir) {
          oldBetween = betweenItems;
          betweenItems = isBetween(sortDir, sortWithin, angular.element(e.target).closest(sortWithin), e);
          if (!betweenItems) {
            return removeMarkers(oldBetween);
          }
          if (betweenItems.first.is(oldBetween != null ? oldBetween.first : void 0) && betweenItems.last.is(oldBetween != null ? oldBetween.last : void 0)) {
            return;
          }
          removeMarkers(oldBetween);
          addMarkers(betweenItems);
        }
        return false;
      };
      onDragEnter = function(e) {
        if (!sortDir) {
          element.addClass(actionClasses.ddDragEnterClass);
        }
      };
      onDragLeave = function(e) {
        if (!isWithin(element, e)) {
          element.removeClass(actionClasses.ddDragEnterClass);
          if (betweenItems) {
            removeMarkers(betweenItems);
            betweenItems = null;
          }
        }
      };
      onDrop = function(e) {
        var dragData, dragModel, dragModelIndex, dropModelIndex, el, _ref, _ref1;

        if (e.preventDefault) {
          e.preventDefault();
        }
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        el = angular.element(ddChannel.getDragElement());
        dragData = el.data('ddDragData');
        dragModel = el.scope()[el.attr('dd-draggable')];
        if (sortDir && betweenItems) {
          removeMarkers(betweenItems);
          dragModelIndex = dragModel.indexOf(dragData);
          dropModelIndex = -1;
          if ((_ref = betweenItems.first) != null ? _ref.length : void 0) {
            dropModelIndex = sortWithin.index(betweenItems.first);
          } else if ((_ref1 = betweenItems.last) != null ? _ref1.length : void 0) {
            dropModelIndex = sortWithin.index(betweenItems.last);
          }
          if (dropModelIndex === -1) {
            /* this shouldn't happen
            */

            debugger;
          }
          if (dropModel === dragModel) {
            scope.$apply(function() {
              dragModel.splice(dragModelIndex, 1);
              return dropModel.splice(dropModelIndex - (dragModelIndex < dropModelIndex ? 1 : 0), 0, dragData);
            });
          } else {
            true;
          }
          betweenItems = null;
        } else {
          scope.$apply(function() {
            dragModel.splice(dragModel.indexOf(dragData), 1);
            return dropModel.push(dragData);
          });
        }
        element.removeClass(actionClasses.ddDragEnterClass);
      };
      ddChannel.onChannelActivate(attrs.ddChannel, function() {
        element.bind("dragover", onDragOver);
        element.bind("dragenter", onDragEnter);
        element.bind("dragleave", onDragLeave);
        element.bind("drop", onDrop);
        element.addClass(actionClasses.ddDropTargetClass);
        return sortWithin = element.children();
      });
      return ddChannel.onChannelDeactivate(attrs.ddChannel, function() {
        element.unbind("dragover", onDragOver);
        element.unbind("dragenter", onDragEnter);
        element.unbind("drop", onDrop);
        element.removeClass(actionClasses.ddDropTargetClass);
        return sortWithin = null;
      });
    };
  });

}).call(this);
